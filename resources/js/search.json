[[{"i":"powershell-niv2","l":"Powershell Niv.2","p":["Le but de cette formation de perfectionnement en Powershell est de donner les clés et les techniques pour passer d'un code \"vite-fait\" à un code:","Fiable","Robuste","Maintenable"]}],[{"l":"Construire son code"},{"l":"Tout commence par une commande","p":["On identifira rapidement une ou deux commandes qui seront le coeur de notre code.","Celles qui récupéreront l'essentiel des données souhaités ou qui feront l'action finale voulue par notre code.","L’idée est de connaitre précisément le fonctionnement de ces commandes et de savoir identifier les propriétés et les méthodes des objets renvoyés par ces commandes et ce que nous aurons à manipuler.","La construction de notre code consistera ensuite à entourer ces commandes de validations, de logique, de contrôle d'erreur et de formatage des données renvoyées"]},{"l":"Définir un squelette","p":["Les Inputs- A l'aide des paramètres, on valide, on nomme et on contrôle les entrées","Les Outputs- On définit et on structure les données qui devront être renvoyés par notre code","Les contrôles- On traite les erreurs possible, et on rends notre code assez verbeux pour faciliter son debug."]},{"l":"Si on code une fonction","p":["La fonction devra être le plus mono tâche et spécialisée possible. On doit pouvoir réutiliser cette fonction telle quelle, dans un contexte différent."]},{"l":"Si on code un script","p":["Dans le cas d'un script, l'attention doit être portée sur la factorisation du code. Si on doit répéter un bloc de code plusieurs fois dans le script, c'est que ce bout de code doit devenir une fonction."]}],[{"l":"Les paramètres"},{"l":"Options de paramètres"},{"l":"Mandatory","p":["Cette option permet de rendre un paramètre obligatoire. Si ce paramètre est oublié à l'appel du script ou de la fonction, un prompt apparaitra pour founir une valeur."]},{"l":"Position","p":["Si une position est renseignée, le script ou la fonction pourront être appelés sans préciser le nom du paramètre. La valeur des paramètres sera attribuée en fonction de l'ordre dans lesquelles ils ont été renseignés.","Par exemple, la commande Get-ChildItem à un paramètre Path qui une position 0. Cette commande s'exécutera donc de la même manière dans tous les cas suivant:","Dans le dernier exemple, le paramètre Exclude sera ignoré dans la position, car nommé."]},{"l":"Parameter Set Name","p":["Les ParameterSetName permettent de changer le comportement du code en fonction d'un groupe de paramètre.","Les règles suivantes s'appliquent au ParameterSetName:","Seul un Set de paramètre peut être utilisé lors de l'appel de la fonction ou du script.","Si aucun Set n'est précisé, le paramètre appartient à tous les Sets.","Un paramètre peut appartenir à plusieurs Set."]},{"l":"ValueFromPipeline","p":["Ce boolean permet de définir que ce paramètre pourra prendre sa valeur depuis le pipeline ."]},{"l":"ValueFromPipelineByPropertyName","p":["ValueFromPipelineByPropertyName permet de lier un paramètre à une propriété de l'objet recu dans le pipeline par leur nom.","Les deux doivent avoir le même type. Ici dans l'exemple, la propriété Name d'un objet service est un [string] et peut donc être récupérer par le paramètre $Name de notre commande.","On peut utiliser les alias de paramètres pour faire correspondre notre paramètre à plusieurs nom de propriétés possible."]},{"l":"ValueFromRemainingArguments","p":["ValueFromRemainingArguments permet de spécifier que ce paramètre acceptera tous les arguments restant qui seront passés à la ligne de commande."]},{"l":"Attributs de paramètres"},{"l":"Alias","p":["L'attribut alias permet de spécifier un ou plusieurs nom alternatif pour un paramètres. Il peut être utilisé pour founir un nom court au paramètre ou pour le faire correspondre à plusieurs nom de propriétés possibles lorsqu'il est utilisé avec ValueFromPipelineByPropertyName."]},{"l":"ValidateNotNull","p":["L'attribut ValidateNotNull spécifie que la valeur du paramètre ne peut pas être $null"]},{"l":"ValidateNotNullOrEmpty","p":["L’attribut ValidateNotNullOrEmpty spécifie que la valeur affectée ne peut pas être l’une des valeurs suivantes :","$null","une chaine vide","un tableau ou une liste vide @()"]},{"l":"ValidateSet","p":["L'attribut ValidateSet spécifie un ensemble de valeurs valide pour ce paramètre et permet l'auto-complétion lors de la saisie de la valeur.","Cette validation se fera à chaque assignation de cette variable :","Cette exemple renverra l'erreur suivante:"]},{"l":"ValidateCount","p":["L'attribut ValidateCount spécifie le nombre de valeur minimal et maximal autorisé pour un paramètre"]},{"l":"ValidateLength","p":["Dans le cas d'un paramètre de type [string]. L'attribut ValidateLength spécifie le nombre de caractère minimal et maximal pour la valeur du paramètre."]},{"l":"ValidateRange","p":["Dans le cas d'un paramètre de type [int] ou [double]. L'attribut ValidateRange spécifie la valeur minimale et maximal que ce paramètre peut recevoir comme valeur."]},{"l":"ValidatePattern","p":["L'attribut ValidatePattern permet d'utiliser une expression régulière (RegEx) pour valider la valeur d'un paramètre.","Dans cet exemple, on validera que la valeur du paramètre -Telephone soit un numéro de téléphone français valide :"]},{"l":"ValidateScript","p":["L'attribut ValidateScript permettra de fournir un bloc de code qui sera exécuté pour valider la valeur du paramètre. Ce bout de code devra renvoyer une variable de type [bool]($true| $false ).","Dans ce bloc de script, fera référence à la valeur du paramètre spécifié.","Dans cet exemple, on validera que le chemin renseigné en valeur du paramètre -Path existe :"]},{"l":"AllowNull","p":["L'attribut AllowNull permet à la valeur d'un paramètre obligatoire d'être $null"]},{"l":"AllowEmptyString","p":["L'attribut AllowEmptyString permet à la valeur d'un paramètre obligatoire de type [string] d'être vide"]},{"l":"AllowEmptyCollection","p":["L'attribut AllowEmptyCollection permet à la valeur d'un paramètre obligatoire d'être une collection vide @()"]},{"i":"voir-plus-sur-learnmicrosoftcom","l":"Voir plus sur learn.microsoft.com","p":["--"]}],[{"l":"Renvoyer un objet en sortie","p":["Dans la plupart des cas, votre script aura à renvoyer des données. Il convient alors de le faire dans la philophie de Powershell et de les renvoyer sous forme d'objets.","Nous utiliserons pour cela un [pscustomobject]","Prenon l'exemple d'un code qui récupère des informations sur des machines à l'aide des commandes CimInstance(Remplacant de WmiObject) :","Nous aurons plusieurs variables, alimentés par différentes commandes dont nous souhaitons consolider la sortie en un objet :","Dans le cas où notre code est éxécuté sur plusieurs cibles, nous créerons notre [pscustomobject] dans notre boucle ou dans le bloc process d'une fonction avancée pour consolider la sortie sous forme de collection.","Si la collection obtenue dans la boucle doit servir dans un traitement plus loin dans le code, la boucle elle même pourra être renvoyée dans une variable.","On voit souvent dans ce cas, la création d'une liste vide et son incrémentation dans la boucle. Cette méthode est à proscrire pour des raisons de performance et de lisibilité.","Il existe une autre syntaxe pour la création du [pscustomobject]:"]}],[{"l":"Beautify and Simplify your code","p":["Il existe plusieurs méthodes à connaitre pour simplifier et faciliter la lisibilité de votre code.","Rappelez vous de l'existence des ces méthodes avant de vous lancer dans des bouts de code alambiqués."]},{"l":"Splatting","p":["Le splatting est une technique consistant à définir les paramètres d'une commande sous forme de [hashtable].","Le principal avantage de cette technique est qu'elle permet de rendre plus lisible certaines commandes qui peuvent devenir trés longue.","Prenons l'exemple d'une commande standard :","En utilsant la méthode du splatting, on regroupe les paramètres dans une hashtable que nous appelerons ensuite dans la commande avec le préfixe","Le deuxième avantage est de pouvoir adapter les paramètres en fonction de certaines conditions sans avoir à répéter plusieurs fois la commande dans notre code:","Plusieurs \"splat\" peuvent être combinés:"]},{"l":"Format Operator","p":["Les Format Operators permettent de simplifier des manipulations sur des chaînes qui pourrait néccéssiter plusieurs ligne de code:"]},{"l":"Arrondir une decimal à X chiffre aprés la virgule"},{"i":"modifier-laffichage-dune-suite-de-chiffre-selon-un-template","l":"Modifier l'affichage d'une suite de chiffre selon un template"},{"l":"Créer une liste incrémentielle"},{"l":"Afficher un chiffre en pourcentage"},{"l":"Afficher un nombre sur X digits","p":["Voir plus :"]},{"l":"Type Accelerators","p":["Les Type Accelerators sont des méthodes de classe .NET. Ils peuvent aussi faciliter certaines opérations et contrôles"]},{"i":"vérifier-la-validité-dune-adresse-ip-ou-dune-url","l":"Vérifier la validité d'une adresse IP ou d'une URL"},{"l":"Créer un objet de type version"},{"l":"RegEx","p":["Les expression régulières peuvent faire peur en apparence mais sont trés efficaces pour extraire une information d'une chaîne de caractère:"]}],[{"i":"utiliser-verbose-debug-output","l":"Utiliser Verbose, Debug Output"},{"l":"Connaitre les différents canaux de sorties","p":["Il est utile de connaitre les 6 canaux de sorties de Powershell:","Canal","Description","1 - Success","C'est le pipeline classique de toute commande en succés. Celui qui s'affiche dans la console ou est renvoyé dans une variable.","2 - Error","3 - Warning","4 - Verbose","5 - Debug","6 - Informational"]},{"l":"Ajouter des sorties Verbose et Debug","p":["La déclaration [CmdletBinding()] permet d'activer les CommonsParameters sur votre fonction ou votre script, dont -Verbose et -Debug.","Ces commandes ont pour but de faciliter le troubleshoot de votre code et de suivre son déroulement.","Les commandes et permettront respectivement de définir vos messages et s'afficheront respectivement en présence des paramètres -Verbose et -Debug à l'appel de votre code.","L'activation de ces paramètres activeront le Verbose et le Debug sur l'ensemble des commandes les prenant en compte dans votre code:","On peut désactiver la sortie Verbose ou Debug d'une commande en désactivant le paramètre de manière explicite: -Verbose:$false"]},{"l":"Warning Output","p":["fonctionne comme les commandes précédentes, à la différence que les messages de type Warning sont activés par defaut."]},{"l":"Informational Output","p":["permet d'écrire des messages d'information. Il permet de remplacer le classique Write-Host pour écrire des messages informatifs. Mais permet comme Write-Verbose et Write-Debug d'activer ou non son affichage à l'exécution de la commande.","Write-Information permet aussi de tagguer ces messages pour pouvoir filtrer ces messages"]},{"l":"Output Preference","p":["Les outputs de type Warning, Error, ou Information peuvent etre paramétrés en entrée de la commande ou du script via les paramètres:","-WarningAction","-ErrorAction","-InformationAction","ou via les variables automatiques respectives:","$WarningPreference","$ErrorPreference","$InformationPreference","Ces paramètres et ces variables peuvent recevoir les valeurs suivantes:","Affiche les messages et continue l'exécution (Valeur par defaut)","Cache les messages et continue l'exécution","Supprime le message et continue l'éxécution. Dans le cas de -ErrorActionPreference, n'alimente pas la variable $Error","Supprime le message et demande confirmation avant de continuer l'éxécution.","Affiche le message et stoppe l'éxécution."]}],[{"l":"Gérer les erreurs","p":["En Powershell, il existe deux types d'erreur:","Une erreur est émise mais le reste du code continu à s'éxécuter.","Une erreur sera émise et l'éxécution du code sera arrété immédiatement.","La variable $ErrorActionPreference et le paramètre -ErrorAction permettent de changer le comportement de votre code en cas d'erreur Non-Terminating. Ils peuvent prendre les valeurs suivantes :","Emet une erreur et continue l'exécution (valeur par défaut)","N'émet aucun message d'erreur et continue l'éxécution. Impossible à \"catcher\" dans le code.","Supprime le message et continue l'éxécution. Dans le cas de -ErrorActionPreference, n'alimente pas la variable $Error. Impossible à \"catcher\" dans le code.","Emet un message d'erreur et demande confirmation avant de continuer l'éxécution.","Affiche le message et stoppe l'éxécution. C'est ce comportement que nous pourrons catcher dans le code.","Supprimer l'ensemble des erreurs dans son script en configurant $ErrorActionPreference = SilentlyContinue au début de son script est une mauvaise habitude à ne pas prendre.","Dans le cas où nous configurons ErrorAction = Stop, nous indiquons à Powershell de stopper toute éxécution en cas d'erreur. Dans le cas d'une boucle, une seule erreur dans celle ci, arretera toute les itérations de la boucle.","Dans cette exemple, si une seule machine est injoignable via la commande Get-CimInstance, la boucle ne renverra rien:"]},{"i":"try--catch","l":"Try / Catch","p":["Pour gérer et catcher les erreurs Terminating, il convient de les utiliser au sein d'un block Try/Catch","Dans un bloc catch, la variable correspondra au message de l'erreur qui a déclenchée son exécution"]},{"i":"catcher-par-type-dexception","l":"Catcher par type d'exception","p":["Il est possible de renseigner plusieur block catch en définisant à chacun le type d'exception qui les déclencheras.","Ici, cela nous permettra, par exemple, de définir si la suppression d'un fichier a échoué parce que le fichier est déja supprimé ou bien parce que nous n'avons pas les droits de le supprimer :","Juste aprés avoir rencontré l'erreur, éxécuter :","Pour rappel: contient toutes les erreurs de la session, de la plus récente à la plus ancienne. $Error[0] renvoie donc la dernière erreur rencontrée."]},{"l":"Bloc Finally","p":["Il est possible d'ajouter à un Try/Catch le bloc Finally. Celui-ci s'éxécutera à la fin du Try\\Catch, que des erreurs aient été rencontrées ou non."]}],[{"l":"Comment Based Help","p":["On peut intégrer une aide dans sa fonction ou son script via un bloc de commentaire dédié:"]}],[{"l":"Les Guidelines","p":["Inutile de décrire vos actions, c'est détailler la raison pour laquelle un bout de code est présent qui importe.","Utilisez les alias et épargnez vous de taper les paramètres dans votre terminal, mais jamais dans votre code !","Par convention, on utilisera le PascalCase pour le nommage : $MaVariable","Dans VSCode, Clic Droit> Mettre le document en forme"]}],[{"l":"JSON Data Consolidation","p":["Cloner le resository sur votre machine:","A partir du dossier \\Workshop\\Data Consolidation\\SampleData et des fichiers qu'il contient. Coder une fonction qui renverra sous forme d'objet :","Le nombre de fichier traités","Le nombre d'items total","Le nombre total d'erreurs","La moyenne des warnings","Le premier job éxécuté","Le dernier job éxécuté","Cette fonction devra recevoir en paramètre un chemin d'accés vers les fichiers (à minima)"]}],[{"l":"Computer Info","p":["Coder une fonction qui pourra requêter une machine distante et renvoyer:","Son nom","Son OS + Numéro de version complet","Nombre de coeur CPU","Quantité de RAM","L'espace restant sur le disque C","Cette fonction devra pouvoir recevoir les machines cibles depuis le pipeline. Aprés une commande Get-ADComputer par exemple..."]}],[{"l":"Create AD Users","p":["Cloner le resository sur votre machine:","A partir d'un fichier du répertoire \\Workshop\\Generate AD Users\\, créer une fonction qui depuis ce fichier en entrée, pourra générer des utilisateurs dans le domaine.","Le champ \"Service\" du fichier définira l'OU cible qui devras être créee si néccéssaire.","Cette fonction devra recevoir en paramètre un chemin d'accés vers le fichier (à minima)"]},{"l":"Aide"}]]